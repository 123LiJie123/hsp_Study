——线程相关概念
 -程序
 是为完成特定任务、用某种语言编写的一组指令的集合。
 -进程
 1、进程是指运行中的程序，比如我们使用QQ，就启动了一个进程，操作系统就会为该进程分配内存空间。当我们
 使用迅雷，又启动了一个进程，操作系统 将为迅雷分配新的内存空间。

 2、进程是程序的一次执行过程，或是正在运行的一个程序。是动态过程：有它自身的产生、存在和消亡的过程。

 - 线程
 1、线程是由进程创建的，是进程的一个实体

 2、一个进程可以拥有多个线程。

 3、当main线程启动一个子线程，主线程不会阻塞它是和子线程是交替执行的

 - 其他相关概念
 1、单线程：
 同一个时刻，只允许执行一个线程

 2、多线程：
 同一个时刻，可以执行多个线程，比如：一个QQ进程，可以同时打开多个聊天窗口，一个迅雷进程，可以同时下载多个文件。

 3、并发： 同一个时刻，多个任务交替执行，造成一种“貌似同时”的错觉，简单的说，单核CPU实现的多任务就是并发。

 4、并行：同一个时刻，多个任务同时执行。多核CPU可以实现并行，或者并发和并行同时发生。


 -- 创建线程的基本方式
 - 创建线程的两种方式
   java中真正的多线程是start中的start0()方法,run()方法只是一个普通方法,通过start0方法实现多线程序的机制去调用run方法实现多线程程序的运行.

   private native void start0();   native：是一个本地方法，其是由jvm机去调用，底层是c/c++实现

  （1） 继承Thread类，重写run方法
  （2）实现Runnable,重写run方法
  当某个类已经实现另一个类不能再继承Thread类后，可以通过实现Runnable接口来实现多线程。（静态代理的方法）

  - 继承Thread和实现Runnable的区别
   从java的设计来看，通过继承Thread或者实现Runnable接口来创建线程本质上没有区别，但实现Runnable接口更加适合多个线程共享一个资源的情况，并且
   避免了单继承的限制。

 ——线程终止【ThreadExit.java】
  1、 当线程完成任务后，会自动退出
  2、还可以通过使用变量来控制run方法退出的方式停止线程，即通知方式。

 ——线程常用方法
 第一组【ThreadMethod01.java】
  setName:  设置线程名称，使之与参数name相同
  getName:  返回该线程的名称
  start:    使该线程开始执行；java虚拟机底层调用该线程的start0方法
  run：     调用线程对象run方法
  setPriority: 更改线程的优先级
  getPriority: 获取线程的优先级
  sleep:       //在指定的毫秒内让当前正在执行的线程休眠（暂停执行）
  interrupt:   //中断线程,但并没有真正的结束线程。一般用于中断正在休眠的线程
 第二组【ThreadMethod02.java】
  yield：   线程的礼让。让出cpu，让其他线程执行，但礼让的时间不确定，所以也不一定礼让成功。
  joij:     线程的插队。插队的线程一旦插队成功，则肯定先执行完插队的线程所有任务。

设置用户线程和守护线程【ThreadMethod03.java】
 1、用户线程: 也叫工作线程，当线程的任务执行完或通知方式结束
 2、守护线程： 一般是为工作线程服务的，当所有的用户线程结束，守护线程自动结束
 3、常见的守护线程：垃圾回收机制


 ——线程的生命周期
  线程状态，线程可以处于以下状态之一：【ThreadState.java】
  NEW:           尚未启动的线程处于此状态。
  RUNNABLE：     在Java虚拟机中执行的线程处于此状态  【细化分READY状态和Running状态】
  BLOCKED：      被阻塞等待监视器锁定的线程处于此状态
  WAITING：      正在等待另一个线程执行特定动作的线程处于此状态。
  TIMED_WAITING：正在等待另一个线程执行动作达到指定等待时间的线程处于此状态。
  TERMINATED：   已退出的线程处于此状态。


  —— 线程同步机制
  1、在多线程编程，一些敏感数据不允许被多个线程同时访问，此时就使用同步访问技术，保证数据
  在任何时刻，最多有一个线程访问，以保证数据的完整性。
  2、也可以理解：线程同步，即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，
   直到该线程完成操作，其他线程才能对该内存地址进行操作。

   - 同步的具体方法
   1、同步代码块  【SellTicket.java】
   2、synchronized还可以放在方法声明中，表示整个方法-为同步方法 synchronized只能在同一个对象中起作用，如果不同对象可以把synchronized标注的方法改为static方法。

   - 互斥锁
   1、Java语言中，引入了对象互斥锁的概念，来保证共享数据操作的完整性。
   2、每个对象都对应于一个可称为"互斥锁"的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象。
   3、关键字synchronized来与对象的互斥锁联系。当某个对象用synchronized修饰时，表明该对象在任一时刻只能由一个线程访问。
   4、同步的局限性：导致程序的执行效率要降低
   5、同步方法（非静态的）的锁可以是this，也可以是其他对象（要求是同一个对象）
   6、同步方法(静态的)的锁为当前类本身。

   - 线程死锁【DeadLock.java】
   多个线程都占用了对方的锁资源，但不肯相让，导致了死锁，在编程时一定要避免死锁的发生。

   - 释放锁
   1、当前线程的同步方法、同步代码块执行结束
   2、当前线程在同步代码块、同步方法中遇到break、return。
   3、当前线程在同步代码块、同步方法中出现了未处理的Error或Exception,导致异常结束
   4、当前线程在同步代码块、同步方法中执行了线程对象wait()方法，当前线程暂停，并释放锁。

   下面操作不会释放锁
   1、线程执行同步代码块或同步方法时，程序调用Thread.sleep()、Thread.yield()方法暂停当前线程的执行，不会释放锁。
   2、线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起，该线程不会释放锁。
   提示：应尽量避免使用suspend()和resume()来控制线程，该方法不再推荐使用。

